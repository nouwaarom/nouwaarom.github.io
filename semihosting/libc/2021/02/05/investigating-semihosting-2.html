<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Semihosting: Printing to stdout</title>
  <meta name="description" content="When using printf() when semihosting the printf function uses semihosting functions to print to the PC console. We will investigate how this works.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://nouwaarom.com/semihosting/libc/2021/02/05/investigating-semihosting-2.html">
  
  
  <link rel="alternate" type="application/rss+xml" title="Now why?" href="https://nouwaarom.com/feed.xml">

  

  
  <meta property="og:title" content="Semihosting: Printing to stdout">
  <meta property="og:site_name" content="Now why?">
  <meta property="og:url" content="https://nouwaarom.com/semihosting/libc/2021/02/05/investigating-semihosting-2.html">
  <meta property="og:description" content="When using printf() when semihosting the printf function uses semihosting functions to print to the PC console. We will investigate how this works.">
  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="">
  <meta name="twitter:title" content="Semihosting: Printing to stdout">
  <meta name="twitter:description" content="When using printf() when semihosting the printf function uses semihosting functions to print to the PC console. We will investigate how this works.">
  
    <meta name="twitter:creator" content="">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  
  <!-- Counter.dev Analytics -->
  <script>if(!sessionStorage.getItem("_swa")&&document.referrer.indexOf(location.protocol+"//"+location.host)!== 0){fetch("https://counter.dev/track?"+new URLSearchParams({referrer:document.referrer,screen:screen.width+"x"+screen.height,user:"nouwaarom",utcoffset:"1"}))};sessionStorage.setItem("_swa","1");</script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Now why?</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="https://github.com/nouwaarom">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Semihosting: Printing to stdout</h1>
    
    <p class="post-meta"><time datetime="2021-02-05T00:00:00-06:00" itemprop="datePublished">Feb 5, 2021</time> •
  
    
    
  
    
    
  



</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>This is part two of a series, part one can be found <a href="/embedded/c/initialize_monitor_handles/2021/01/30/investigating-semihosting.html">here</a>.
In this post we will investigate how we can print using semihosting.
In the previous post we noticed that <em>puts</em> was used to print a string to stdout.
<!--more--></p>

<h2 id="reentrancy-and-opening-stdout">Reentrancy and opening stdout</h2>
<p>Let us look at the definition of <em>puts</em>, which can be found in <a href="https://github.com/mirror/newlib-cygwin/blob/master/newlib/libc/stdio/puts.c">puts.c</a>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span>
<span class="nf">puts</span> <span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">_puts_r</span> <span class="p">(</span><span class="n">_REENT</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>We notice that <em>puts</em> does nothing but call <em>_puts_r</em>.
The function <em>_puts_r</em> is reentrant. But what does it mean that a function is reentrant?</p>
<blockquote>
  <p>In computing, a computer program or subroutine is called reentrant if multiple invocations can safely run concurrently on a single processor system, where a reentrant procedure can be interrupted in the middle of its execution and then safely be called again (“re-entered”) before its previous invocations complete execution. - Wikipedia</p>
</blockquote>

<p>It is very important that this function is reentrant as we want to be able to use it from the main loop and in interrupt handlers without our system crashing.
We will investigate how reentrancy is guaranteed for this function.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><details><summary><span class="c1">...</span></summary>
<span class="cm">/*
DESCRIPTION
&lt;&lt;puts&gt;&gt; writes the string at &lt;[s]&gt; (followed by a newline, instead of
the trailing null) to the standard output stream.

The alternate function &lt;&lt;_puts_r&gt;&gt; is a reentrant version.  The extra
argument &lt;[reent]&gt; is a pointer to a reentrancy structure.

RETURNS
If successful, the result is a nonnegative integer; otherwise, the
result is &lt;&lt;EOF&gt;&gt;.

PORTABILITY
ANSI C requires &lt;&lt;puts&gt;&gt;, but does not specify that the result on
success must be &lt;&lt;0&gt;&gt;; any non-negative value is permitted.

Supporting OS subroutines required: &lt;&lt;close&gt;&gt;, &lt;&lt;fstat&gt;&gt;, &lt;&lt;isatty&gt;&gt;,
&lt;&lt;lseek&gt;&gt;, &lt;&lt;read&gt;&gt;, &lt;&lt;sbrk&gt;&gt;, &lt;&lt;write&gt;&gt;.
*/</span>

<span class="cp">#include</span> <span class="cpf">&lt;_ansi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;reent.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"fvwrite.h"</span><span class="cp">
#include</span> <span class="cpf">"local.h"</span><span class="cp">
</span></details>

<span class="cm">/*
 * Write the given string to stdout, appending a newline.
 */</span>

<span class="kt">int</span>
<span class="nf">_puts_r</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_reent</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef _FVWRITE_IN_STREAMIO // newlib
</span><details><summary><span class="c1">...</span></summary>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">strlen</span> <span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="k">struct</span> <span class="n">__suio</span> <span class="n">uio</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__siov</span> <span class="n">iov</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

  <span class="n">iov</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">iov</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">iov</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">iov</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">uio</span><span class="p">.</span><span class="n">uio_resid</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">uio</span><span class="p">.</span><span class="n">uio_iov</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">uio</span><span class="p">.</span><span class="n">uio_iovcnt</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="n">_REENT_SMALL_CHECK_INIT</span> <span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
  <span class="n">fp</span> <span class="o">=</span> <span class="n">_stdout_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
  <span class="n">CHECK_INIT</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
  <span class="n">_newlib_flockfile_start</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="n">ORIENT</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">__sfvwrite_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uio</span><span class="p">)</span> <span class="o">?</span> <span class="n">EOF</span> <span class="o">:</span> <span class="sc">'\n'</span><span class="p">);</span>
  <span class="n">_newlib_flockfile_end</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</details>
<span class="cp">#else // newlib_nano
</span>  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">EOF</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
  <span class="n">_REENT_SMALL_CHECK_INIT</span> <span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

  <span class="n">fp</span> <span class="o">=</span> <span class="n">_stdout_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
  <span class="n">CHECK_INIT</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
  <span class="n">_newlib_flockfile_start</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="n">ORIENT</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="cm">/* Make sure we can write.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cantwrite</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__sputc_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
	<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__sputc_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="sc">'\n'</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

  <span class="n">result</span> <span class="o">=</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="nl">err:</span>
  <span class="n">_newlib_flockfile_end</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">}</span></code></pre></figure>

<p>Let us first look at the preprocessor statements to see which code will get compiled.
There is a conditional compilation on <em>_FVWRITE_IN_STREAMIO</em>.
With some googeling we find that this flag can be used to disable the io vector buffer. <a href="https://sourceware.org/legacy-ml/newlib/2013/msg00146.html">source</a>
It turns out the buffer is available for newlib but not for newlib nano.
For the sake of simplicity we will explore the case without a buffer.
The flow of this function is a follows:</p>
<ul>
  <li>Make sure the file to write to (stdout) is open.</li>
  <li>Get a lock on the file we want to write to.</li>
  <li>Write the string to this file character by character.</li>
  <li>Release the lock on the file.</li>
</ul>

<h2 id="making-sure-stdout-is-open">Making sure stdout is open</h2>
<p>At the top of <em>_puts_r</em> we notice this code.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
  <span class="n">_REENT_SMALL_CHECK_INIT</span> <span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

  <span class="n">fp</span> <span class="o">=</span> <span class="n">_stdout_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
  <span class="n">CHECK_INIT</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span></code></pre></figure>

<p>First a file pointer is created. The _REENT_SMALL_CHECK_INIT(ptr) does nothing for our compile flags, so we ignore it.
The statement <em>_stdout_r</em> is defined in <code class="highlighter-rouge">stdio.h</code> as follows:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define _stdout_r(x)	((x)-&gt;_stdout)</span></code></pre></figure>

<p>Which in our case expands to <em>ptr-&gt;_stdout</em>.</p>

<h3 id="the-reentrancy-struct">The reentrancy struct</h3>
<p>Notice that <em>ptr</em> is reference to the reentrancy structure (<em>_REENT</em>).
The macro <em>_REENT</em> expands to a global variable of type <em>struct _reent*</em>
The global variable is defined in <code class="highlighter-rouge">impure.c</code> as:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="k">struct</span> <span class="n">_reent</span> <span class="n">__ATTRIBUTE_IMPURE_DATA__</span> <span class="n">impure_data</span> <span class="o">=</span> <span class="n">_REENT_INIT</span> <span class="p">(</span><span class="n">impure_data</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">_reent</span> <span class="o">*</span><span class="n">__ATTRIBUTE_IMPURE_PTR__</span> <span class="n">_impure_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">impure_data</span><span class="p">;</span></code></pre></figure>

<p>This structure is quite large. The definition is in <code class="highlighter-rouge">newlib/libc/include/sys/reent.h</code></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">_reent</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">_errno</span><span class="p">;</span>			<span class="cm">/* local copy of errno */</span>

  <span class="cm">/* FILE is a big struct and may change over time.  To try to achieve binary
     compatibility with future versions, put stdin,stdout,stderr here.
     These are pointers into member __sf defined below.  */</span>
  <span class="n">__FILE</span> <span class="o">*</span><span class="n">_stdin</span><span class="p">,</span> <span class="o">*</span><span class="n">_stdout</span><span class="p">,</span> <span class="o">*</span><span class="n">_stderr</span><span class="p">;</span>

<details><summary><span class="c1">...</span></summary>
  <span class="kt">int</span>  <span class="n">_inc</span><span class="p">;</span>			<span class="cm">/* used by tmpnam */</span>
  <span class="kt">char</span> <span class="n">_emergency</span><span class="p">[</span><span class="n">_REENT_EMERGENCY_SIZE</span><span class="p">];</span>

  <span class="cm">/* TODO */</span>
  <span class="kt">int</span> <span class="n">_unspecified_locale_info</span><span class="p">;</span>	<span class="cm">/* unused, reserved for locale stuff */</span>
  <span class="k">struct</span> <span class="n">__locale_t</span> <span class="o">*</span><span class="n">_locale</span><span class="p">;</span><span class="cm">/* per-thread locale */</span>
</details>
  <span class="kt">int</span> <span class="n">__sdidinit</span><span class="p">;</span>		<span class="cm">/* 1 means stdio has been init'd */</span>

<details><summary><span class="c1">...</span></summary>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__cleanup</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_reent</span> <span class="o">*</span><span class="p">);</span>

  <span class="cm">/* used by mprec routines */</span>
  <span class="k">struct</span> <span class="n">_Bigint</span> <span class="o">*</span><span class="n">_result</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_result_k</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_Bigint</span> <span class="o">*</span><span class="n">_p5s</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_Bigint</span> <span class="o">**</span><span class="n">_freelist</span><span class="p">;</span>

  <span class="cm">/* used by some fp conversion routines */</span>
  <span class="kt">int</span> <span class="n">_cvtlen</span><span class="p">;</span>			<span class="cm">/* should be size_t */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_cvtbuf</span><span class="p">;</span>

  <span class="k">union</span>
    <span class="p">{</span>
      <span class="k">struct</span>
        <span class="p">{</span>
          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_unused_rand</span><span class="p">;</span>
          <span class="kt">char</span> <span class="o">*</span> <span class="n">_strtok_last</span><span class="p">;</span>
          <span class="kt">char</span> <span class="n">_asctime_buf</span><span class="p">[</span><span class="n">_REENT_ASCTIME_SIZE</span><span class="p">];</span>
          <span class="k">struct</span> <span class="n">__tm</span> <span class="n">_localtime_buf</span><span class="p">;</span>
          <span class="kt">int</span> <span class="n">_gamma_signgam</span><span class="p">;</span>
          <span class="n">__extension__</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">_rand_next</span><span class="p">;</span>
          <span class="k">struct</span> <span class="n">_rand48</span> <span class="n">_r48</span><span class="p">;</span>
          <span class="n">_mbstate_t</span> <span class="n">_mblen_state</span><span class="p">;</span>
          <span class="n">_mbstate_t</span> <span class="n">_mbtowc_state</span><span class="p">;</span>
          <span class="n">_mbstate_t</span> <span class="n">_wctomb_state</span><span class="p">;</span>
          <span class="kt">char</span> <span class="n">_l64a_buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
          <span class="kt">char</span> <span class="n">_signal_buf</span><span class="p">[</span><span class="n">_REENT_SIGNAL_SIZE</span><span class="p">];</span>
          <span class="kt">int</span> <span class="n">_getdate_err</span><span class="p">;</span>
          <span class="n">_mbstate_t</span> <span class="n">_mbrlen_state</span><span class="p">;</span>
          <span class="n">_mbstate_t</span> <span class="n">_mbrtowc_state</span><span class="p">;</span>
          <span class="n">_mbstate_t</span> <span class="n">_mbsrtowcs_state</span><span class="p">;</span>
          <span class="n">_mbstate_t</span> <span class="n">_wcrtomb_state</span><span class="p">;</span>
          <span class="n">_mbstate_t</span> <span class="n">_wcsrtombs_state</span><span class="p">;</span>
	  <span class="kt">int</span> <span class="n">_h_errno</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">_reent</span><span class="p">;</span>
  <span class="cm">/* Two next two fields were once used by malloc.  They are no longer
     used. They are used to preserve the space used before so as to
     allow addition of new reent fields and keep binary compatibility.   */</span>
      <span class="k">struct</span>
        <span class="p">{</span>
<span class="cp">#define _N_LISTS 30
</span>          <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">_nextf</span><span class="p">[</span><span class="n">_N_LISTS</span><span class="p">];</span>
          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_nmalloc</span><span class="p">[</span><span class="n">_N_LISTS</span><span class="p">];</span>
        <span class="p">}</span> <span class="n">_unused</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">_new</span><span class="p">;</span>

<span class="cp"># ifndef _REENT_GLOBAL_ATEXIT
</span>  <span class="cm">/* atexit stuff */</span>
  <span class="k">struct</span> <span class="n">_atexit</span> <span class="o">*</span><span class="n">_atexit</span><span class="p">;</span>	<span class="cm">/* points to head of LIFO stack */</span>
  <span class="k">struct</span> <span class="n">_atexit</span> <span class="n">_atexit0</span><span class="p">;</span>	<span class="cm">/* one guaranteed table, required by ANSI */</span>
<span class="cp"># endif
</span>
  <span class="cm">/* signal info */</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">**</span><span class="p">(</span><span class="n">_sig_func</span><span class="p">))(</span><span class="kt">int</span><span class="p">);</span>

  <span class="cm">/* These are here last so that __FILE can grow without changing the offsets
     of the above members (on the off chance that future binary compatibility
     would be broken otherwise).  */</span>
  <span class="k">struct</span> <span class="n">_glue</span> <span class="n">__sglue</span><span class="p">;</span>		<span class="cm">/* root of glue chain */</span>
</details>
<span class="cp"># ifndef _REENT_GLOBAL_STDIO_STREAMS
</span>  <span class="n">__FILE</span> <span class="n">__sf</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>  		<span class="cm">/* first three file descriptors */</span>
<span class="cp"># endif
</span><span class="p">};</span></code></pre></figure>

<p>This reentrancy struct is initialized by <em>_REENT_INIT</em>, which is defined in <code class="highlighter-rouge">reent.h</code>. 
In this macro the <em>_stdin</em>, <em>_stdout</em>, and <em>_stderror</em> elements are initialized with the addresses of <em>__sf[0]</em>, <em>__sf[1]</em> and <em>__sf[2]</em> respectively.
This means that these file pointers point to valid blocks of memory.</p>

<h3 id="opening-stdin-stdout-and-stderr">Opening stdin, stdout and stderr</h3>
<p>The files themeselves are not initialized yet, this is done by <em>CHECK_INIT(ptr)</em>.
This function checks if stdio is marked initialized, and if not initializes it:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define CHECK_INIT(ptr) \
#define CHECK_INIT(ptr, fp) \
  do								\
    {								\
      struct _reent *_check_init_ptr = (ptr);			\
      if ((_check_init_ptr) &amp;&amp; !(_check_init_ptr)-&gt;__sdidinit)	\
	__sinit (_check_init_ptr);				\
    }								\
  while (0)</span></code></pre></figure>

<p>This weird looking do-while loop is added so that we can use this macro with a semicolon without a syntax error, as explained <a href="https://stackoverflow.com/questions/154136/why-use-apparently-meaningless-do-while-and-if-else-statements-in-macros">here</a>.</p>

<p>The definition of <em>__sinit</em> can be found in <code class="highlighter-rouge">findfp.c</code>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */</span>
<span class="kt">void</span>
<span class="nf">__sinit</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_reent</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__sinit_lock_acquire</span> <span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">__sdidinit</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">__sinit_lock_release</span> <span class="p">();</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

<details><summary><span class="c1">...</span></summary>
  <span class="cm">/* make sure we clean up on exit */</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">__cleanup</span> <span class="o">=</span> <span class="n">_cleanup_r</span><span class="p">;</span>	<span class="cm">/* conservative */</span>

  <span class="n">s</span><span class="o">-&gt;</span><span class="n">__sglue</span><span class="p">.</span><span class="n">_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifndef _REENT_SMALL
# ifndef _REENT_GLOBAL_STDIO_STREAMS
</span>  <span class="n">s</span><span class="o">-&gt;</span><span class="n">__sglue</span><span class="p">.</span><span class="n">_niobs</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">__sglue</span><span class="p">.</span><span class="n">_iobs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">__sf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="cp"># endif </span><span class="cm">/* _REENT_GLOBAL_STDIO_STREAMS */</span><span class="cp">
#else
</span>  <span class="n">s</span><span class="o">-&gt;</span><span class="n">__sglue</span><span class="p">.</span><span class="n">_niobs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">__sglue</span><span class="p">.</span><span class="n">_iobs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="cm">/* Avoid infinite recursion when calling __sfp  for _GLOBAL_REENT.  The
     problem is that __sfp checks for _GLOBAL_REENT-&gt;__sdidinit and calls
     __sinit if it's 0. */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">_GLOBAL_REENT</span><span class="p">)</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">__sdidinit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp"># ifndef _REENT_GLOBAL_STDIO_STREAMS
</span>  <span class="n">s</span><span class="o">-&gt;</span><span class="n">_stdin</span> <span class="o">=</span> <span class="n">__sfp</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">_stdout</span> <span class="o">=</span> <span class="n">__sfp</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">_stderr</span> <span class="o">=</span> <span class="n">__sfp</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="cp"># else </span><span class="cm">/* _REENT_GLOBAL_STDIO_STREAMS */</span><span class="cp">
</span>  <span class="n">s</span><span class="o">-&gt;</span><span class="n">_stdin</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__sf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">_stdout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__sf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">_stderr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__sf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="cp"># endif </span><span class="cm">/* _REENT_GLOBAL_STDIO_STREAMS */</span><span class="cp">
#endif
</span>
<span class="cp">#ifdef _REENT_GLOBAL_STDIO_STREAMS
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">__sf</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">_cookie</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_GLOBAL_REENT</span><span class="o">-&gt;</span><span class="n">__sglue</span><span class="p">.</span><span class="n">_niobs</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">_GLOBAL_REENT</span><span class="o">-&gt;</span><span class="n">__sglue</span><span class="p">.</span><span class="n">_iobs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__sf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">stdin_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">__sf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">stdout_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">__sf</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">stderr_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">__sf</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="p">}</span>
</details>
<span class="cp">#else </span><span class="cm">/* _REENT_GLOBAL_STDIO_STREAMS */</span><span class="cp">
</span>  <span class="n">stdin_init</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">_stdin</span><span class="p">);</span>
  <span class="n">stdout_init</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">_stdout</span><span class="p">);</span>
  <span class="n">stderr_init</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">_stderr</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* _REENT_GLOBAL_STDIO_STREAMS */</span><span class="cp">
</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">__sdidinit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="n">__sinit_lock_release</span> <span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<p>The purpose of this post is researching how printing works, so we will discuss how stdout is opened. The code for stdin and stderr is very similar.
The only thing that <em>stdout_init</em> does is calling.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="n">std</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">__SWR</span> <span class="o">|</span> <span class="n">__SLBF</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>The two flags mean that the file can be written to and that it is line buffered.
This means that the actual write will occur only when a newline character occurs (or a flush is executed).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">std</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_flags2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_bf</span><span class="p">.</span><span class="n">_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_bf</span><span class="p">.</span><span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_lbfsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">memset</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_mbstate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">_mbstate_t</span><span class="p">));</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_cookie</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_read</span> <span class="o">=</span> <span class="n">__sread</span><span class="p">;</span>
<span class="cp">#ifndef __LARGE64_FILES
</span>  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_write</span> <span class="o">=</span> <span class="n">__swrite</span><span class="p">;</span>
<span class="cp">#else </span><span class="cm">/* __LARGE64_FILES */</span><span class="cp">
</span><details><summary><span class="c1">...</span></summary>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_write</span> <span class="o">=</span> <span class="n">__swrite64</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_seek64</span> <span class="o">=</span> <span class="n">__sseek64</span><span class="p">;</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">__SL64</span><span class="p">;</span>
</details>
<span class="cp">#endif </span><span class="cm">/* __LARGE64_FILES */</span><span class="cp">
</span>  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_seek</span> <span class="o">=</span> <span class="n">__sseek</span><span class="p">;</span>
<span class="cp">#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
</span>  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_close</span> <span class="o">=</span> <span class="n">__sclose</span><span class="p">;</span>
<span class="cp">#else </span><span class="cm">/* _STDIO_CLOSE_STD_STREAMS */</span><span class="cp">
</span>  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_close</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* _STDIO_CLOSE_STD_STREAMS */</span><span class="cp">
#if !defined(__SINGLE_THREAD__) &amp;&amp; !(defined(_REENT_SMALL) &amp;&amp; !defined(_REENT_GLOBAL_STDIO_STREAMS))
</span>  <span class="n">__lock_init_recursive</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_lock</span><span class="p">);</span>
  <span class="cm">/*
   * #else
   * lock is already initialized in __sfp
   */</span>
<span class="cp">#endif
</span>
<details><summary><span class="c1">...</span></summary>
<span class="cp">#ifdef __SCLE
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">__stextmode</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_file</span><span class="p">))</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">__SCLE</span><span class="p">;</span>
<span class="cp">#endif
</span></details>
<span class="p">}</span></code></pre></figure>

<p>Now we know how the file is opened and initialized and how all function pointers are set, let us continue our exploration.</p>

<h2 id="locking-a-file-intermezzo">Locking a file (intermezzo)</h2>
<p>The functions <em>_newlib_flockfile_start</em> and <em>_newlib_flockfile_end</em> are used for file locking.
These functions are defined in <code class="highlighter-rouge">newlib/libc/stdio/local.h</code>, the implementation of <em>_flockfile</em> and <em>_funlockfile</em> are found in <code class="highlighter-rouge">newlib/libc/include/sys/stdio.h</code>.
We will combine them to make things a bit easier to read.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define _newlib_flockfile_start(_fp) \
    { \
        if (!(_fp-&gt;_flags2 &amp; __SNLK)) \
          _flockfile (_fp)
</span>
<span class="cp">#define _newlib_flockfile_exit(_fp) \
        if (!(_fp-&gt;_flags2 &amp; __SNLK)) \
          _funlockfile(_fp); \

#define _newlib_flockfile_end(_fp) \
        if (!(_fp-&gt;_flags2 &amp; __SNLK)) \
          _funlockfile(_fp); \
    }
</span>
<span class="cp">#define _flockfile(fp) (((fp)-&gt;_flags &amp; __SSTR) ? 0 : __lock_acquire_recursive((fp)-&gt;_lock))
#define _funlockfile(fp) (((fp)-&gt;_flags &amp; __SSTR) ? 0 : __lock_release_recursive((fp)-&gt;_lock))</span></code></pre></figure>

<p>I found it quite cool that <em>_start</em> and <em>_end</em> define a scope together so that you have cannot forget to do an <em>_end</em>.
It is not in the scope of this article to discuss the locking methods used, so we will not explain this further here.</p>

<h2 id="printing-a-character">Printing a character</h2>
<p>Remember that in <em>_puts_r</em> all characters are written out with the following loop:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__sputc_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
	<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__sputc_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="sc">'\n'</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span></code></pre></figure>

<p>This loop calls <em>__sputc_r</em> for all characters in the string, until a string termintation character (‘\0’) occurs or the file is full.
After that a newline is also printed using <em>__sputc_r</em>.</p>

<h3 id="buffers-and-flushing">Buffers and flushing</h3>
<p>The definition of <em>sputc_r</em> can be found at <code class="highlighter-rouge">newlib/libc/include/sys/stdio.h</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">_ELIDABLE_INLINE</span> <span class="kt">int</span> <span class="nf">__sputc_r</span><span class="p">(</span><span class="k">struct</span> <span class="n">_reent</span> <span class="o">*</span><span class="n">_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">_p</span><span class="p">)</span> <span class="p">{</span>
<details><summary><span class="c1">...</span></summary>
<span class="cp">#ifdef __SCLE
</span>    <span class="k">if</span> <span class="p">((</span><span class="n">_p</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">__SCLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">_c</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">)</span>
      <span class="n">__sputc_r</span> <span class="p">(</span><span class="n">_ptr</span><span class="p">,</span> <span class="sc">'\r'</span><span class="p">,</span> <span class="n">_p</span><span class="p">);</span>
<span class="cp">#endif
</span></details>
    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">_p</span><span class="o">-&gt;</span><span class="n">_w</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">_p</span><span class="o">-&gt;</span><span class="n">_w</span> <span class="o">&gt;=</span> <span class="n">_p</span><span class="o">-&gt;</span><span class="n">_lbfsize</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">_c</span> <span class="o">!=</span> <span class="sc">'\n'</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">_p</span><span class="o">-&gt;</span><span class="n">_p</span><span class="o">++</span> <span class="o">=</span> <span class="n">_c</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">__swbuf_r</span><span class="p">(</span><span class="n">_ptr</span><span class="p">,</span> <span class="n">_c</span><span class="p">,</span> <span class="n">_p</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>The implementation of <em>__swbuf_r</em> can be found in <code class="highlighter-rouge">newlib/libc/stdio/wbuf.c</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*
 * Write the given character into the (probably full) buffer for
 * the given file.  Flush the buffer out if it is or becomes full,
 * or if c=='\n' and the file is line buffered.
 */</span>

<span class="kt">int</span>
<span class="nf">__swbuf_r</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_reent</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
       <span class="k">register</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span>
       <span class="k">register</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

  <span class="cm">/* Ensure stdio has been initialized.  */</span>

  <span class="n">CHECK_INIT</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>

  <span class="cm">/*
   * In case we cannot write, or longjmp takes us out early,
   * make sure _w is 0 (if fully- or un-buffered) or -_bf._size
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */</span>

  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_w</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_lbfsize</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cantwrite</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">c</span><span class="p">;</span>

  <span class="n">ORIENT</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="cm">/*
   * If it is completely full, flush it out.  Then, in any case,
   * stuff c into the buffer.  If this causes the buffer to fill
   * completely, or if c is '\n' and the file is line buffered,
   * flush it (perhaps a second time).  The second flush will always
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_p</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_bf</span><span class="p">.</span><span class="n">_base</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_bf</span><span class="p">.</span><span class="n">_size</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">_fflush_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_w</span><span class="o">--</span><span class="p">;</span>
  <span class="o">*</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_p</span><span class="o">++</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">n</span> <span class="o">==</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_bf</span><span class="p">.</span><span class="n">_size</span> <span class="o">||</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">__SLBF</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_fflush_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>We will not discuss the buffering here but we can see that 
<em>_fflush_r</em> is called if the buffer is full or if we the file is line buffered and we see a newline character.</p>

<p>The source of <em>_fflush_r</em> can be found in <code class="highlighter-rouge">newlib/libc/stdio/fflush.c</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span>
<span class="nf">_fflush_r</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_reent</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
       <span class="k">register</span> <span class="kt">FILE</span> <span class="o">*</span> <span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<details><summary><span class="c1">...</span></summary>
<span class="cp">#ifdef _REENT_SMALL
</span>  <span class="cm">/* For REENT_SMALL platforms, it is possible we are being
     called for the first time on a std stream.  This std
     stream can belong to a reentrant struct that is not
     _REENT.  If CHECK_INIT gets called below based on _REENT,
     we will end up changing said file pointers to the equivalent
     std stream off of _REENT.  This causes unexpected behavior if
     there is any data to flush on the _REENT std stream.  There
     are two alternatives to fix this:  1) make a reentrant fflush
     or 2) simply recognize that this file has nothing to flush
     and return immediately before performing a CHECK_INIT.  Choice
     2 is implemented here due to its simplicity.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_bf</span><span class="p">.</span><span class="n">_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* _REENT_SMALL  */</span><span class="cp">
</span></details>

  <span class="n">CHECK_INIT</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">_newlib_flockfile_start</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">__sflush_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
  <span class="n">_newlib_flockfile_end</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Flush a single file, or (if fp is NULL) all files.  */</span>

<span class="cm">/* Core function which does not lock file pointer.  This gets called
   directly from __srefill. */</span>
<span class="kt">int</span>
<span class="nf">__sflush_r</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_reent</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
       <span class="k">register</span> <span class="kt">FILE</span> <span class="o">*</span> <span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="k">register</span> <span class="n">_READ_WRITE_BUFSIZE_TYPE</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">register</span> <span class="n">_READ_WRITE_RETURN_TYPE</span> <span class="n">t</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">flags</span><span class="p">;</span>

  <span class="n">flags</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__SWR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
<details><summary><span class="c1">...</span></summary>
<span class="cp">#ifdef _FSEEK_OPTIMIZATION
</span>      <span class="cm">/* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">__SNPT</span><span class="p">;</span>
<span class="cp">#endif
</span>      <span class="cm">/* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_r</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_ur</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_seek</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="kt">int</span> <span class="n">tmp_errno</span><span class="p">;</span>
<span class="cp">#ifdef __LARGE64_FILES
</span>	  <span class="n">_fpos64_t</span> <span class="n">curoff</span><span class="p">;</span>
<span class="cp">#else
</span>	  <span class="n">_fpos_t</span> <span class="n">curoff</span><span class="p">;</span>
<span class="cp">#endif
</span>
	  <span class="cm">/* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */</span>
	  <span class="n">tmp_errno</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span><span class="p">;</span>
	  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	  <span class="cm">/* Get the physical position we are at in the file.  */</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">__SOFF</span><span class="p">)</span>
	    <span class="n">curoff</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">;</span>
	  <span class="k">else</span>
	    <span class="p">{</span>
	      <span class="cm">/* We don't know current physical offset, so ask for it.
		 Only ESPIPE and EINVAL are ignorable.  */</span>
<span class="cp">#ifdef __LARGE64_FILES
</span>	      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">__SL64</span><span class="p">)</span>
		<span class="n">curoff</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_seek64</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_cookie</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_CUR</span><span class="p">);</span>
	      <span class="k">else</span>
<span class="cp">#endif
</span>		<span class="n">curoff</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_seek</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_cookie</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_CUR</span><span class="p">);</span>
	      <span class="k">if</span> <span class="p">(</span><span class="n">curoff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1L</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
		  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">EOF</span><span class="p">;</span>
		  <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span> <span class="o">==</span> <span class="n">ESPIPE</span> <span class="o">||</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span> <span class="o">==</span> <span class="n">EINVAL</span><span class="p">)</span>
		    <span class="p">{</span>
		      <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		      <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span> <span class="o">=</span> <span class="n">tmp_errno</span><span class="p">;</span>
		    <span class="p">}</span>
		  <span class="k">else</span>
		    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">__SERR</span><span class="p">;</span>
		  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="p">}</span>
            <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">__SRD</span><span class="p">)</span>
            <span class="p">{</span>
              <span class="cm">/* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */</span>
              <span class="n">curoff</span> <span class="o">-=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_r</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">HASUB</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
                <span class="n">curoff</span> <span class="o">-=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_ur</span><span class="p">;</span>
            <span class="p">}</span>
	  <span class="cm">/* Now physically seek to after byte last read.  */</span>
<span class="cp">#ifdef __LARGE64_FILES
</span>	  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">__SL64</span><span class="p">)</span>
	    <span class="n">curoff</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_seek64</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_cookie</span><span class="p">,</span> <span class="n">curoff</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
	  <span class="k">else</span>
<span class="cp">#endif
</span>	    <span class="n">curoff</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_seek</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_cookie</span><span class="p">,</span> <span class="n">curoff</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">curoff</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span> <span class="o">==</span> <span class="mi">0</span>
	      <span class="o">||</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span> <span class="o">==</span> <span class="n">ESPIPE</span> <span class="o">||</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span> <span class="o">==</span> <span class="n">EINVAL</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="cm">/* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */</span>
<span class="cp">#ifdef _FSEEK_OPTIMIZATION
</span>	      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__SNPT</span><span class="p">;</span>
<span class="cp">#endif
</span>	      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_p</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_bf</span><span class="p">.</span><span class="n">_base</span><span class="p">;</span>
	      <span class="k">if</span> <span class="p">((</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">__SOFF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">curoff</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">curoff</span><span class="p">;</span>
	      <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span> <span class="o">=</span> <span class="n">tmp_errno</span><span class="p">;</span>
	      <span class="k">if</span> <span class="p">(</span><span class="n">HASUB</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
		<span class="n">FREEUB</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	    <span class="p">}</span>
	  <span class="k">else</span>
	    <span class="p">{</span>
	      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">__SERR</span><span class="p">;</span>
	      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
	    <span class="p">}</span>
	<span class="p">}</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</details>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_bf</span><span class="p">.</span><span class="n">_base</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Nothing to flush.  */</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_p</span> <span class="o">-</span> <span class="n">p</span><span class="p">;</span>		<span class="cm">/* write this much */</span>

  <span class="cm">/*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_w</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__SLBF</span> <span class="o">|</span> <span class="n">__SNBF</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_bf</span><span class="p">.</span><span class="n">_size</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">t</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_write</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_cookie</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
          <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">__SERR</span><span class="p">;</span>
          <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="n">p</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>In this loop all characters are written using <em>fp-&gt;_write</em>.
This function returns the number of bytes written. If not all bytes could be written in the first call more calls are made for the rest of the data.
Remember that in the initialization this function pointer was assigned <em>__swrite</em>.</p>

<h3 id="writing-a-character">Writing a character</h3>
<p>The code for <em>__swrite</em> can be found in <code class="highlighter-rouge">stdio/stdio.c</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">_READ_WRITE_RETURN_TYPE</span>
<span class="nf">__swrite</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_reent</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
       <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span>
       <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
       <span class="n">_READ_WRITE_BUFSIZE_TYPE</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">register</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="p">)</span> <span class="n">cookie</span><span class="p">;</span>
  <span class="kt">ssize_t</span> <span class="n">w</span><span class="p">;</span>
<details><summary><span class="c1">...</span></summary>
<span class="cp">#ifdef __SCLE
</span>  <span class="kt">int</span> <span class="n">oldmode</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span></details>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">__SAPP</span><span class="p">)</span>
    <span class="n">_lseek_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_file</span><span class="p">,</span> <span class="p">(</span><span class="n">_off_t</span><span class="p">)</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">);</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__SOFF</span><span class="p">;</span>	<span class="cm">/* in case O_APPEND mode is set */</span>

<details><summary><span class="c1">...</span></summary>
<span class="cp">#ifdef __SCLE
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">__SCLE</span><span class="p">)</span>
    <span class="n">oldmode</span> <span class="o">=</span> <span class="n">setmode</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_file</span><span class="p">,</span> <span class="n">O_BINARY</span><span class="p">);</span>
<span class="cp">#endif
</span></details>

  <span class="n">w</span> <span class="o">=</span> <span class="n">_write_r</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

<details><summary><span class="c1">...</span></summary>
<span class="cp">#ifdef __SCLE
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">oldmode</span><span class="p">)</span>
    <span class="n">setmode</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_file</span><span class="p">,</span> <span class="n">oldmode</span><span class="p">);</span>
<span class="cp">#endif
</span></details>

  <span class="k">return</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Stdout is not opened in append mode so we can ignore that part.
What is left is the call to <em>_write_r</em>.
This function is defined in <code class="highlighter-rouge">reent/writer.c</code></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">_ssize_t</span>
<span class="nf">_write_r</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_reent</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
     <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>
     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
     <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">_ssize_t</span> <span class="n">ret</span><span class="p">;</span>

  <span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">_ssize_t</span><span class="p">)</span><span class="n">_write</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">cnt</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">_errno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The <em>_write</em> function is system specific. For arm it is defined in<code class="highlighter-rouge">sys/arm/syscalls.c</code> as:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* file, is a user file descriptor. */</span>
<span class="kt">int</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span>
<span class="n">_write</span> <span class="p">(</span><span class="kt">int</span> <span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">findslot</span> <span class="p">(</span><span class="n">remap_handle</span> <span class="p">(</span><span class="n">file</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_swiwrite</span> <span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">error</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="n">MAX_OPEN_FILES</span><span class="p">)</span>
    <span class="n">openfiles</span><span class="p">[</span><span class="n">slot</span><span class="p">].</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">len</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Now we are finally there. In <em>_swiwrite</em> a block of data is written using semihosting.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* file, is a valid internal file handle.
   Returns the number of bytes *not* written. */</span>
<span class="kt">int</span>
<span class="nf">_swiwrite</span> <span class="p">(</span><span class="kt">int</span> <span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">fh</span> <span class="o">=</span> <span class="n">remap_handle</span> <span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="cp">#ifdef ARM_RDI_MONITOR
</span>  <span class="kt">int</span> <span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

  <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
  <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">len</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">do_AngelSWI</span> <span class="p">(</span><span class="n">AngelSWI_Reason_Write</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
<span class="cp">#else
</span><details><summary><span class="c1">...</span></summary>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">r0</span> <span class="n">asm</span><span class="p">(</span><span class="s">"r0"</span><span class="p">)</span> <span class="o">=</span> <span class="n">fh</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">r1</span> <span class="n">asm</span><span class="p">(</span><span class="s">"r1"</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">r2</span> <span class="n">asm</span><span class="p">(</span><span class="s">"r2"</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">len</span><span class="p">;</span>

  <span class="n">asm</span> <span class="p">(</span><span class="s">"swi %a4"</span>
       <span class="o">:</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">r0</span><span class="p">)</span>
       <span class="o">:</span> <span class="s">"0"</span><span class="p">(</span><span class="n">fh</span><span class="p">),</span> <span class="s">"r"</span><span class="p">(</span><span class="n">r1</span><span class="p">),</span> <span class="s">"r"</span><span class="p">(</span><span class="n">r2</span><span class="p">),</span> <span class="s">"i"</span><span class="p">(</span><span class="n">SWI_Write</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">r0</span><span class="p">;</span>
</details>
<span class="cp">#endif
</span><span class="p">}</span></code></pre></figure>

<h2 id="conclusion">Conclusion</h2>
<p>There is a lot of complicated code to write a string and there seems to be quite some overhead.
But the call to write bytes using semihosting is simple.</p>

<p>Thank you for reading. If you have questions or suggestions, please open an issue or mergerequest on the <a href="https://github.com/nouwaarom/nouwaarom.github.io">repository</a> for this site.</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://nouwaarom.com/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
